Додаткові коментарі та пояснення по використаним рішенням:
1) Використання локального сховища у рішеннях, які застосувавались рініше, 
   надавало моливість не хвилюватись, що збережені дані одного користувача 
   будуть відображені іншому користувачеві. Це забезпечувалось на рівні браузера.
   Через те, що у поточному рішенні використовується бек-енд, то потрібно було 
   виконати якийсь механізм, для забезпечення приватності персональної інформації 
   користувачів, адже відображення інформації одних користувачів іншим є 
   недопустимою.
2) Хотілося б обов'язково відмітити, що імплементоване рішення, особливо з 
   використаним бек-ендом (безкоштовна версія mockapi.io) та використаними 
   механізмами обмеження доступу не є (і не може бути) безпечним рішенням, а сам
   механізм обмеження доступу ставив перед собою ціль забезпечити найбільш 
   можливо якісний користувальницький доступ. 
   Всі запити на бек-енд (включаючи enpoint'и та api токен) можливо відслідити 
   через dev tools в браузері чи інші механізми або ж на рівні маршрутизації. 
   Більш того, тестовий бек-енд виконає будь-які валідні запити, а інформація 
   може бути видозміненя або ж видалена, без додаткової авторизації або 
   аутентифікації користувача.
   Ці ризики можливо частково обійти використовуючи платну версію бекенду, або 
   ж використовуючи інший бек-енд, чи написавши власний, з додатковими
   механізмами аутентифікції/авторизації.
3) З іншого боку, використання бек-енду надало можливість підключення до одного
   й того ж користувача декілька клієнтів та відображення інформації на 
   декількох пристрояї одночасно, що в свою чергу створило новий виклик щодо 
   синхронізації інйормації поміж цими пристроями. Тому було прийнято рішення 
   щодо використання наступної стратегії синхронізації:
    1) Користувач містить набір унікальних ідентифікаторів і ПЕРЕД КОЖНИМ ЗАПИТОМ
       на зміну даних виконується запит на сервер, чи така комбінація 
       ідентифікаторів користувача співпадає з тою, що на сервері (перевірка 
       наразі виконується на клієнті, а не на сервері, що не є правильним та 
       безпечним підходом та має бути змінено при використанні іншого бек-енду з 
       незначими змінами у коді, але наразі зроблено саме таким чином для 
       поліпшення користувальницького досвіду).
    2) Якщо індентифікатори користувача валідні, виконується запит на сервер для 
       отримання списку найбільш актуальної інформації від серверу. Виконується 
       порівняння з локальними даними, та тільки в разі відмінності версій, 
       виконується перезапис локальної інформації. (Це так само можливо 
       перенести на сторону серверу).
       Це забезпечує синронованість даних сервер-клієнть, де на клієнті можуть 
       бути застарілі дані лише максимально на одну дію (напр. додавання чи 
       видалення контакту викличе синхронізацію списку). 
    3) Додатково стратегією синхронізації передбачена переодична (раз в 30 секунд)
       синхронізація контакті. При чому реалізацією передбачено, щоб періодична
       синхронізація виконувалась лише у випадку, коли вкладка показана (у 
       випадку коли користувач знаходиться на іншій вкладці браузера, періодичні 
       запити не надсилаються, таким самим зберігаючи ресурси машини). 
       Повернення ж до відображення вкладки, після того як вона була схована, 
       викличе додаткову синхронізацію.
4) Унікальні ідентифікатори користувача створюються у момент строрення нового 
   користувача. Цей процес пов'язаний з відсутністю будь-якої інформації у 
   локальному сховищу.
5) Виористання унікальних ідентифікаторів користувача дозволило реалізувати наступний функціонал:
   1) Зміна веріфікаційного ключа користувача, якщо дані користувача співпадають
      (умовно якщо користувач має право на зміну). Так як ключ створюється під 
      час створення користувача, то про нього знає лише користувач який спонукав
      його створення і тільки він може його знати. Таким чином можливо обмежити 
      доступ до інформації іншим користувачам, які раніше "отримали доступ" до 
      інформації.
      Передбачено можливість доступу до інформації всіх бажаючих (любі ключі), 
      якщо на сервері ключ порожній. Можна назвати це, щось як "публічні контакти".
   2) Зміна користувача та підключення інших пристроїв (напр. мобільного телефону)
      до відображення інформації одного й того ж самого користувача застосунку 
      при задаванні валідної коомбінпції унікальних ідентифікаторів користувача.
6) **не вирішено** - додатковий опис проблеми до того, що описано вище 
   передача unique project token у рядку запиту, який видно у 
   всіх запитах та всім маршрутизаторам по дорозі. Це не проблема, якщо 
   розглядати token не у якості токену, але у якості частини url або свого 
   унікального доменного ім'я. Суть проблеми: потенційний хакер знає який 
   endpoint якого сервісу атакувати.
4) **не вирішено** - додатковий опис проблеми до того, що описано вище 
   забезпечення безпеки api (проблема самого api, не застосунку) - 
   можливо отримати доступ до всіх користувачів та їх даних - можливе часткове 
   вирішення: платна версія mockapi, яка дозволяє відключити відповідь на деякі 
   запити (напр. GET /users). З іншого боку у безплатній версії mockapi 
   неможливо використати напр. uuid у якості id, тому залишиться просто 
   перебирати id по ендпоінту users. Якщо відокремити захист api окремо, у 
   відриві від застосуну, то можливо не використовувати очевидні 
   endpoints по типу "users", "clients" чи інше, а переіменувати його у щось 
   неочевидне чи додати якусь "salt", яка б зберігалась у secrets репозиторію - 
   доступ до конкретного значення та його зміна використовуючи бекенд та 
   аутентифікації самого mockapi. Це не гарантує безпеку api, але ускладнить 
   пошук (перебором) правильного "ключа" до users. Покращує захист api у відриві 
   від застосунку чи при черегляді коду репозиторію (де не буде видно фінального 
   edpoint'у), а запити застосунку на api повністю елімінують цей свосіб, так як 
   можливо подивитись на endpoint у запиті.